
use std::iter::FromIterator;

use proc_macro2::{Delimiter, Group, Span, TokenStream, TokenTree};
use quote::format_ident;
use syn::{
    braced, bracketed, parenthesized, parse::ParseStream, token, Attribute, Data, DataEnum,
    DeriveInput, Error, Generics, Ident, Index, LitInt, Member, Result, Token, Type,
};

#[derive(Clone)]
pub(crate) struct Scheduled<'a> {
    pub(crate) original: &'a Attribute,
    pub(crate) args: TokenStream,
}

/// NOTE(alex): The attribute we want to parse.
///
/// These are the attributes on each variant, in our case we only have one called `scheduled`, and
/// it's always required.
pub(crate) struct Attributes<'a> {
    pub(crate) scheduled: Scheduled<'a>,
}

/// NOTE(alex): Field of an enum (or struct, but this macro only deals with enums).
pub(crate) struct Field<'a> {
    pub(crate) original: &'a syn::Field,
    pub(crate) attributes: Attributes<'a>,
    pub(crate) member: Member,
    pub(crate) ty: &'a Type,
}

/// NOTE(alex): Variant of an enum.
pub(crate) struct Variant<'a> {
    pub(crate) original: &'a syn::Variant,
    pub(crate) attributes: Attributes<'a>,
    pub(crate) ident: Ident,
    pub(crate) fields: Vec<Field<'a>>,
}

pub(crate) struct Enum<'a> {
    pub(crate) original: &'a DeriveInput,
    pub(crate) ident: Ident,
    pub(crate) generics: &'a Generics,
    pub(crate) variants: Vec<Variant<'a>>,
}

impl<'a> Attributes<'a> {
    pub(crate) fn get(input: &[Attribute]) -> Result<Attributes> {
        let mut attributes: Option<Attributes> = None;

        for attr in input {
            if attr.path.is_ident("scheduled") {
                let scheduled = Attributes::parse_scheduled_attribute(attr)?;
                attributes = Some(Attributes { scheduled });
            } else {
                return Err(Error::new_spanned(
                    attr,
                    "should only contain one attribute",
                ));
            }
        }

        attributes.ok_or(Error::new_spanned(input[0], "failed getting scheduled"))
    }

    pub(crate) fn parse_scheduled_attribute(attr: &'a Attribute) -> Result<Scheduled> {
        attr.parse_args_with(|input: ParseStream| {
            let scheduled = Scheduled {
                original: attr,
                args: Attributes::parse_token_expr(input, false)?,
            };

            Ok(scheduled)
        })
    }

    pub(crate) fn parse_token_expr(
        input: ParseStream,
        mut begin_expr: bool,
    ) -> Result<TokenStream> {
        let mut tokens = Vec::new();
        while !input.is_empty() {
            if begin_expr && input.peek(Token![.]) {
                if input.peek2(Ident) {
                    input.parse::<Token![.]>()?;
                    begin_expr = false;
                    continue;
                }
            }

            if input.peek2(LitInt) {
                input.parse::<Token![.]>()?;
                let int: Index = input.parse()?;
                let ident = format_ident!("_{}", int.index, span = int.span);
                tokens.push(TokenTree::Ident(ident));
                begin_expr = false;
                continue;
            }

            begin_expr = input.peek(Token![break])
                || input.peek(Token![continue])
                || input.peek(Token![if])
                || input.peek(Token![in])
                || input.peek(Token![match])
                || input.peek(Token![mut])
                || input.peek(Token![return])
                || input.peek(Token![while])
                || input.peek(Token![+])
                || input.peek(Token![&])
                || input.peek(Token![!])
                || input.peek(Token![^])
                || input.peek(Token![,])
                || input.peek(Token![/])
                || input.peek(Token![=])
                || input.peek(Token![>])
                || input.peek(Token![<])
                || input.peek(Token![|])
                || input.peek(Token![%])
                || input.peek(Token![;])
                || input.peek(Token![*])
                || input.peek(Token![-]);

            let token: TokenTree = if input.peek(token::Paren) {
                let content;
                let delimiter = parenthesized!(content in input);
                let nested = Attributes::parse_token_expr(&content, true)?;
                let mut group = Group::new(Delimiter::Parenthesis, nested);
                group.set_span(delimiter.span);
                TokenTree::Group(group)
            } else if input.peek(token::Brace) {
                let content;
                let delimiter = braced!(content in input);
                let nested = Attributes::parse_token_expr(&content, true)?;
                let mut group = Group::new(Delimiter::Brace, nested);
                group.set_span(delimiter.span);
                TokenTree::Group(group)
            } else if input.peek(token::Bracket) {
                let content;
                let delimiter = bracketed!(content in input);
                let nested = Attributes::parse_token_expr(&content, true)?;
                let mut group = Group::new(Delimiter::Brace, nested);
                group.set_span(delimiter.span);
                TokenTree::Group(group)
            } else {
                input.parse()?
            };

            tokens.push(token);
        }

        Ok(TokenStream::from_iter(tokens))
    }
}

impl<'a> Enum<'a> {
    fn from_syn(node: &'a DeriveInput, data: &'a DataEnum) -> Result<Self> {
        let variants = data.variants.iter().map(|node| {
            let mut variant = Variant::from_syn(node,)

        }).collect::<Result<_>>()?;
    }
}

#[proc_macro_derive(FromScheduled, attributes(scheduled))]
pub fn derive_from_scheduled(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = proc_macro2::TokenStream::from(input);

    let output: proc_macro2::TokenStream = {
        let DeriveInput {
            attrs, ident, data, ..
        } = syn::parse2(input).unwrap();

        data.variants.iter();

        todo!()
    };

    proc_macro::TokenStream::from(output)
}


////

let connection_id = self
                    .service
                    .requesting_connection
                    .iter_mut()
                    .find_map(|(connection_id, peer)| {
                        if peer.address == packet.delivery.meta.address {
                            peer.connection.attempts += 1;
                            Some(connection_id.clone())
                        } else {
                            None
                        }
                    })
                    .unwrap_or({
                        let new_peer = Peer::new(
                            self.timer.elapsed(),
                            packet.delivery.meta.address,
                            packet.sequence.get(),
                        );

                        let connection_id = self.service.connection_id_tracker;
                        self.service
                            .requesting_connection
                            .insert(connection_id, new_peer);
                        self.service.connection_id_tracker =
                            ConnectionId::new(connection_id.get() + 1).unwrap();

                        connection_id
                    });

////////////////////


#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]
pub struct ProtocolId(NonZeroU32);

impl ProtocolId {
    pub const fn from_be_bytes(bytes: [u8; size_of::<u32>()]) -> Option<Self> {
        let primitive = u32::from_be_bytes(bytes);
        let non_zero = NonZeroU32::new(primitive);
        if non_zero.is_some() {
            Some(Self(non_zero.unwrap()))
        } else {
            None
        }
    }
}

impl Deref for ProtocolId {
    type Target = NonZeroU32;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for ProtocolId {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl From<NonZeroU32> for ProtocolId {
    fn from(primitive: NonZeroU32) -> Self {
        ProtocolId(primitive)
    }
}


///////////////////////////////////

        if self.service.connected.is_empty() {
            self.events
                .api
                .push(AntarcEvent::Fail(ProtocolError::NoPeersConnected));
        }

        let should_fragment = payload.len() > MAX_FRAGMENT_SIZE;

        match send_to {
            SendTo::Single { connection_id } => {
                debug!("server: SendTo::Single scheduler {:#?}.", connection_id);

                let old_scheduler_length = self.events.scheduler.len();

                if let Some(peer) = self.service.connected.get(&connection_id) {
                    let packet_id = self.packet_id_tracker;

                    if should_fragment {
                        debug!("server: schedule fragment.");

                        let fragments = payload
                            .chunks(MAX_FRAGMENT_SIZE)
                            .enumerate()
                            .map(|(index, chunk)| (index, chunk.to_vec()))
                            .collect::<Vec<_>>();

                        let fragment_total = fragments.len();

                        let mut scheduling = fragments
                            .into_iter()
                            .map(|(fragment_index, payload)| {
                                let scheduled: Scheduled<R, Fragment> = Scheduled::new(
                                    packet_id,
                                    connection_id,
                                    reliability,
                                    payload.clone(),
                                    fragment_index,
                                    fragment_total,
                                    self.timer.elapsed(),
                                    peer.address.clone(),
                                );
                                let scheduling = if reliability {
                                    let scheduled = Scheduled::new_reliable(
                                        packet_id,
                                        connection_id,
                                        payload.clone(),
                                        fragment_index,
                                        fragment_total,
                                        self.timer.elapsed(),
                                        peer.address.clone(),
                                    );

                                    scheduled.into()
                                } else {
                                    let scheduled = Scheduled::new_unreliable(
                                        packet_id,
                                        connection_id,
                                        payload.clone(),
                                        fragment_index,
                                        fragment_total,
                                        self.timer.elapsed(),
                                        peer.address.clone(),
                                    );

                                    scheduled.into()
                                };

                                scheduling
                            })
                            .collect::<Vec<_>>();

                        self.events.scheduler.append(&mut scheduling);
                    } else {
                        debug!("server: schedule non-fragment.");

                        let meta = MetaMessage {
                            packet_type: DataTransfer::PACKET_TYPE,
                        };
                        let message = DataTransfer {
                            meta,
                            connection_id,
                            payload: payload.clone(),
                        };

                        let scheduling = if reliability {
                            let scheduled = Scheduled {
                                packet_id,
                                time: self.timer.elapsed(),
                                address: peer.address.clone(),
                                reliability: Reliable {},
                                message,
                            };

                            scheduled.into()
                        } else {
                            let scheduled = Scheduled {
                                packet_id,
                                time: self.timer.elapsed(),
                                address: peer.address.clone(),
                                reliability: Unreliable {},
                                message,
                            };

                            scheduled.into()
                        };

                        self.events.scheduler.push(scheduling);
                    }
                } else {
                    self.events
                        .api
                        .push(ProtocolError::ScheduledNotConnected(connection_id).into())
                }

                if self.events.scheduler.len() > old_scheduler_length {
                    self.packet_id_tracker += 1;
                }
            }
            SendTo::Multiple { connection_ids } => {
                debug!("server: SendTo::Multiple scheduler {:#?}.", connection_ids);

                let old_scheduler_length = self.events.scheduler.len();

                for connection_id in connection_ids {
                    if let Some(peer) = self.service.connected.get(&connection_id) {
                        let packet_id = self.packet_id_tracker;

                        if should_fragment {
                            debug!("server: schedule fragment.");

                            let fragments = payload
                                .chunks(MAX_FRAGMENT_SIZE)
                                .enumerate()
                                .map(|(index, chunk)| (index, chunk.to_vec()))
                                .collect::<Vec<_>>();

                            let fragment_total = fragments.len();

                            let mut scheduling = fragments
                                .into_iter()
                                .map(|(fragment_index, payload)| {
                                    let scheduling = if reliability {
                                        let scheduled = Scheduled::new_reliable(
                                            packet_id,
                                            connection_id,
                                            payload.clone(),
                                            fragment_index,
                                            fragment_total,
                                            self.timer.elapsed(),
                                            peer.address.clone(),
                                        );

                                        scheduled.into()
                                    } else {
                                        let scheduled = Scheduled::new_unreliable(
                                            packet_id,
                                            connection_id,
                                            payload.clone(),
                                            fragment_index,
                                            fragment_total,
                                            self.timer.elapsed(),
                                            peer.address.clone(),
                                        );

                                        scheduled.into()
                                    };

                                    scheduling
                                })
                                .collect::<Vec<_>>();

                            self.events.scheduler.append(&mut scheduling);
                        } else {
                            debug!("server: schedule non-fragment.");

                            let meta = MetaMessage {
                                packet_type: DataTransfer::PACKET_TYPE,
                            };
                            let message = DataTransfer {
                                meta,
                                connection_id,
                                payload: payload.clone(),
                            };

                            let scheduling = if reliability {
                                let scheduled = Scheduled {
                                    packet_id,
                                    time: self.timer.elapsed(),
                                    address: peer.address.clone(),
                                    reliability: Reliable {},
                                    message,
                                };

                                scheduled.into()
                            } else {
                                let scheduled = Scheduled {
                                    packet_id,
                                    time: self.timer.elapsed(),
                                    address: peer.address.clone(),
                                    reliability: Unreliable {},
                                    message,
                                };

                                scheduled.into()
                            };

                            self.events.scheduler.push(scheduling);
                        }
                    } else {
                        self.events
                            .api
                            .push(ProtocolError::ScheduledNotConnected(connection_id).into())
                    }
                }

                if self.events.scheduler.len() > old_scheduler_length {
                    self.packet_id_tracker += 1;
                }
            }
            SendTo::Broadcast => {
                debug!("server: SendTo::Broadcast scheduler.");

                let old_scheduler_length = self.events.scheduler.len();

                for peer in self.service.connected.values() {
                    let packet_id = self.packet_id_tracker;

                    if should_fragment {
                        debug!("server: schedule fragment.");

                        let fragments = payload
                            .chunks(MAX_FRAGMENT_SIZE)
                            .enumerate()
                            .map(|(index, chunk)| (index, chunk.to_vec()))
                            .collect::<Vec<_>>();

                        let fragment_total = fragments.len();
                        let connection_id = peer.connection.connection_id;

                        let mut scheduling = fragments
                            .into_iter()
                            .map(|(fragment_index, payload)| {
                                let scheduling = if reliability {
                                    let scheduled = Scheduled::new_reliable(
                                        packet_id,
                                        connection_id,
                                        payload.clone(),
                                        fragment_index,
                                        fragment_total,
                                        self.timer.elapsed(),
                                        peer.address.clone(),
                                    );

                                    scheduled.into()
                                } else {
                                    let scheduled = Scheduled::new_unreliable(
                                        packet_id,
                                        connection_id,
                                        payload.clone(),
                                        fragment_index,
                                        fragment_total,
                                        self.timer.elapsed(),
                                        peer.address.clone(),
                                    );

                                    scheduled.into()
                                };

                                scheduling
                            })
                            .collect::<Vec<_>>();

                        self.events.scheduler.append(&mut scheduling);
                    } else {
                        debug!("server: schedule non-fragment.");

                        let meta = MetaMessage {
                            packet_type: DataTransfer::PACKET_TYPE,
                        };
                        let message = DataTransfer {
                            meta,
                            connection_id: peer.connection.connection_id,
                            payload: payload.clone(),
                        };

                        let scheduling = if reliability {
                            let scheduled = Scheduled {
                                packet_id,
                                time: self.timer.elapsed(),
                                address: peer.address.clone(),
                                reliability: Reliable {},
                                message,
                            };

                            scheduled.into()
                        } else {
                            let scheduled = Scheduled {
                                packet_id,
                                time: self.timer.elapsed(),
                                address: peer.address.clone(),
                                reliability: Unreliable {},
                                message,
                            };

                            scheduled.into()
                        };

                        self.events.scheduler.push(scheduling);
                    }
                }

                if self.events.scheduler.len() > old_scheduler_length {
                    self.packet_id_tracker += 1;
                }
            }
        }

////////////////

  //
                                //

                                let scheduled = scheduler!({
                                        packet_id,
                                        connection_id,
                                        payload.clone(),
                                        fragment_index,
                                        fragment_total,
                                        self.timer.elapsed(),
                                        peer.address.clone() } : R);

                                //
                                //